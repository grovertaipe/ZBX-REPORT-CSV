===== config.json =====
{
    "ZABBIX_URL": "http://tu_servidor_zabbix/api_jsonrpc.php",
    "AUTH_TOKEN": "tu_token_de_autenticacion_zabbix",
    "ITEM_KEYS": {
        "filesystem": {
            "percent": "vfs.fs.size[*,pused]",
            "used": "vfs.fs.size[*,used]"
        },
        "memory": {
            "percent": "vm.memory.util",
            "used": "vm.memory.size[used]"
        },
        "cpu": {
            "percent": "system.cpu.util"
        }
    },
    "HOST_TAGS": [
        {"tag": "cliente", "value": "monitoreo", "operator": 1},
        {"tag": "os", "value": "linux", "operator": 1}
    ],
    "CSV_FIELDS": [
        "Host ID", "Nombre", "Dirección IP", "Tipo", "Nombre Item", 
        "Porcentaje Utilizado", "Espacio Usado", 
        "Promedio Porcentaje", "Mínimo Porcentaje", "Máximo Porcentaje",
        "Promedio Usado", "Mínimo Usado", "Máximo Usado"
    ],
    "default_report_name": "zabbix_report",
    "email": {
        "sender": "tu_correo@tudominio.com",
        "recipients": ["destinatario1@ejemplo.com", "destinatario2@ejemplo.com"],
        "subject": "Reporte de Zabbix",
        "body": "Adjunto encontrarás el reporte de Zabbix generado.",
        "smtp_server": "smtp.tudominio.com",
        "smtp_port": 587,
        "use_tls": true,
        "use_authentication": true,
        "username": "tu_usuario@tudominio.com",
        "password": "tu_contraseña_segura"
    }
}

===== main.py =====
import csv
import argparse
from datetime import datetime
from utils import get_date_range, calculate_stats, bytes_to_human_readable, load_config
from zabbix_operations import ZabbixOperations
from email_sender import send_email

def process_items(zabbix, host_id, item_type, time_from, time_till, item_keys):
    percent_key = item_keys[item_type]['percent']
    used_key = item_keys[item_type].get('used')

    percent_items = zabbix.get_items_for_host(host_id, [percent_key])
    used_items = zabbix.get_items_for_host(host_id, [used_key]) if used_key else []

    results = []

    for percent_item in percent_items:
        result = {
            'Tipo': item_type,
            'Nombre Item': percent_item['name'],
            'Porcentaje Utilizado': f"{float(percent_item['lastvalue']):.2f}%"
        }

        trend_data = zabbix.get_trend_data(percent_item['itemid'], time_from, time_till)
        avg, min_val, max_val = calculate_stats(trend_data)
        result.update({
            'Promedio Porcentaje': f"{avg:.2f}%" if avg is not None else "N/A",
            'Mínimo Porcentaje': f"{min_val:.2f}%" if min_val is not None else "N/A",
            'Máximo Porcentaje': f"{max_val:.2f}%" if max_val is not None else "N/A"
        })

        if used_items:
            if item_type == 'memory':
                used_item = used_items[0]
            else:
                used_item = next((item for item in used_items if item['name'].split()[0] == percent_item['name'].split()[0]), None)

            if used_item:
                last_value = bytes_to_human_readable(float(used_item['lastvalue']))
                result['Espacio Usado'] = last_value

                trend_data = zabbix.get_trend_data(used_item['itemid'], time_from, time_till)
                avg, min_val, max_val = calculate_stats(trend_data)
                result.update({
                    'Promedio Usado': bytes_to_human_readable(avg) if avg is not None else "N/A",
                    'Mínimo Usado': bytes_to_human_readable(min_val) if min_val is not None else "N/A",
                    'Máximo Usado': bytes_to_human_readable(max_val) if max_val is not None else "N/A"
                })
            else:
                result.update({
                    'Espacio Usado': 'N/A',
                    'Promedio Usado': 'N/A',
                    'Mínimo Usado': 'N/A',
                    'Máximo Usado': 'N/A'
                })
        else:
            result.update({
                'Espacio Usado': 'N/A',
                'Promedio Usado': 'N/A',
                'Mínimo Usado': 'N/A',
                'Máximo Usado': 'N/A'
            })

        results.append(result)

    return results

def generate_report(config_file, start_date, end_date, report_name=None):
    config = load_config(config_file)
    zabbix = ZabbixOperations(config['ZABBIX_URL'], config['AUTH_TOKEN'])
    time_from, time_till = get_date_range(start_date, end_date)

    if report_name is None:
        report_name = config.get('default_report_name', 'zabbix_report')

    current_date = datetime.now().strftime("%Y-%m-%d")
    output_file = f"{report_name}_{current_date}.csv"

    hosts = zabbix.get_hosts(config['HOST_TAGS'])

    with open(output_file, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=config['CSV_FIELDS'])
        writer.writeheader()

        for host in hosts:
            host_id = host['hostid']
            host_name = host['host']
            ip_address = host['interfaces'][0]['ip']

            for item_type in config['ITEM_KEYS']:
                items_data = process_items(zabbix, host_id, item_type, time_from, time_till, config['ITEM_KEYS'])

                for item_data in items_data:
                    row = {
                        'Host ID': host_id,
                        'Nombre': host_name,
                        'Dirección IP': ip_address
                    }
                    row.update(item_data)
                    writer.writerow(row)

    print(f"El reporte ha sido generado en {output_file}")
    
    # Enviar el reporte por correo electrónico
    send_email(config, output_file)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generar reporte de Zabbix")
    parser.add_argument("config_file", help="Archivo de configuración JSON")
    parser.add_argument("--start_date", help="Fecha de inicio (YYYY-MM-DD), opcional", default=None)
    parser.add_argument("--end_date", help="Fecha de fin (YYYY-MM-DD), opcional", default=None)
    parser.add_argument("--report_name", help="Nombre personalizado para el reporte", default=None)
    args = parser.parse_args()

    # Llamamos a generate_report con el archivo de configuración, fechas opcionales y nombre de reporte personalizado
    generate_report(args.config_file, args.start_date, args.end_date, args.report_name)

===== utils.py =====
import requests
import json
from datetime import datetime, timedelta
from statistics import mean
import os

def zabbix_api_request(url, auth_token, method, params):
    """Función para hacer solicitudes a la API de Zabbix"""
    headers = {"Content-Type": "application/json-rpc"}
    payload = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params,
        "auth": auth_token,
        "id": 1
    }
    response = requests.post(url, data=json.dumps(payload), headers=headers)
    return response.json()

def get_date_range(start_date=None, end_date=None):
    """
    Convierte fechas en formato string a timestamps.
    Si no se proporcionan fechas, usa el mes anterior por defecto.
    El rango va desde el inicio del primer día hasta el inicio del día siguiente al último día especificado.
    """
    if not start_date or not end_date:
        today = datetime.now()
        first_day_last_month = (today.replace(day=1) - timedelta(days=1)).replace(day=1)
        last_day_last_month = today.replace(day=1) - timedelta(days=1)
        start = first_day_last_month
        end = last_day_last_month
    else:
        start = datetime.strptime(start_date, "%Y-%m-%d")
        end = datetime.strptime(end_date, "%Y-%m-%d")
    
    start = start.replace(hour=0, minute=0, second=0, microsecond=0)
    end = end.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)
    
    return int(start.timestamp()), int(end.timestamp())

def calculate_stats(trend_data):
    """Calcula las estadísticas de los datos de tendencia"""
    if not trend_data:
        return None, None, None

    avg_values = [float(item["value_avg"]) for item in trend_data]
    min_values = [float(item["value_min"]) for item in trend_data]
    max_values = [float(item["value_max"]) for item in trend_data]
    
    return mean(avg_values), min(min_values), max(max_values)

def bytes_to_human_readable(size_in_bytes):
    """Convierte bytes a un formato legible por humanos"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_in_bytes < 1024.0:
            return f"{size_in_bytes:.2f} {unit}"
        size_in_bytes /= 1024.0
    return f"{size_in_bytes:.2f} PB"

def load_config(json_file):
    """Carga la configuración desde un archivo JSON."""
    if not os.path.isfile(json_file):
        raise FileNotFoundError(f"El archivo {json_file} no se encuentra.")
    with open(json_file, 'r') as file:
        return json.load(file)

===== email_sender.py =====
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication

def send_email(config, report_file):
    msg = MIMEMultipart()
    msg['From'] = config['email']['sender']
    msg['To'] = ', '.join(config['email']['recipients'])
    msg['Subject'] = config['email']['subject']

    body = config['email']['body']
    msg.attach(MIMEText(body, 'plain'))

    with open(report_file, 'rb') as file:
        part = MIMEApplication(file.read(), Name=report_file)
    part['Content-Disposition'] = f'attachment; filename="{report_file}"'
    msg.attach(part)

    try:
        server = smtplib.SMTP(config['email']['smtp_server'], config['email']['smtp_port'])
        
        if config['email'].get('use_tls', False):
            server.starttls()
        
        if config['email'].get('use_authentication', False):
            server.login(config['email']['username'], config['email']['password'])
        
        server.send_message(msg)
        server.quit()
        print("Correo enviado exitosamente")
    except Exception as e:
        print(f"Error al enviar el correo: {str(e)}")

===== zabbix_operations.py =====
# zabbix_operations.py

from utils import zabbix_api_request

class ZabbixOperations:
    def __init__(self, url, auth_token):
        self.url = url
        self.auth_token = auth_token

    def get_hosts(self, tags):
        """Obtiene la lista de hosts con los tags especificados"""
        params = {
            'output': ['hostid', 'host', 'interfaces'],
            'selectInterfaces': ['ip'],
            'tags': tags
        }
        result = zabbix_api_request(self.url, self.auth_token, "host.get", params)
        return result.get('result', [])

    def get_items_for_host(self, host_id, keys):
        """Obtiene los items para un host"""
        params = {
            'output': 'extend',
            'hostids': [host_id],
            'search': {'key_': keys},
            'monitored': True,
            'searchWildcardsEnabled': True
        }
        result = zabbix_api_request(self.url, self.auth_token, "item.get", params)
        return result.get('result', [])

    def get_trend_data(self, itemid, time_from, time_till):
        """Obtiene los datos de tendencia para un item"""
        params = {
            "output": ["itemid", "clock", "num", "value_min", "value_avg", "value_max"],
            "itemids": [itemid],
            "time_from": time_from,
            "time_till": time_till,
            "limit": "20000"
        }
        result = zabbix_api_request(self.url, self.auth_token, "trend.get", params)
        return result.get('result', [])

